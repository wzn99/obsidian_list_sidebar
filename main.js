/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ListSidebarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/ListView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_LIST_SIDEBAR = "list-sidebar-view";
var ListView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.lists = [];
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_LIST_SIDEBAR;
  }
  getDisplayText() {
    return "List Sidebar";
  }
  getIcon() {
    return "layers";
  }
  async onOpen() {
    await this.loadData();
    this.render();
  }
  async onClose() {
  }
  async loadData() {
    this.lists = await this.plugin.loadLists();
  }
  async saveData() {
    await this.plugin.saveLists(this.lists);
  }
  render() {
    const container = this.containerEl.children[1];
    if (!container) {
      return;
    }
    container.empty();
    container.addClass("list-sidebar-container");
    const listsContainer = container.createDiv("list-sidebar-lists");
    listsContainer.ondragover = (e) => {
      const draggingItem = container.querySelector(".list-sidebar-item.dragging");
      const draggingList = container.querySelector(".list-sidebar-list.dragging");
      if (draggingItem) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
      } else if (draggingList) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
      }
    };
    listsContainer.ondrop = async (e) => {
      const draggingItem = container.querySelector(".list-sidebar-item.dragging");
      const draggingList = container.querySelector(".list-sidebar-list.dragging");
      if (draggingItem) {
        e.preventDefault();
        this.render();
      } else if (draggingList) {
        e.preventDefault();
        if (e.dataTransfer) {
          const fromIndex = parseInt(e.dataTransfer.getData("text/plain"));
          if (!isNaN(fromIndex)) {
            const toIndex = Array.from(listsContainer.children).filter(
              (el) => el.classList.contains("list-sidebar-list")
            ).indexOf(draggingList);
            if (toIndex >= 0 && toIndex < this.lists.length && fromIndex !== toIndex) {
              draggingList.dataset.dragProcessed = "true";
              const [movedList] = this.lists.splice(fromIndex, 1);
              this.lists.splice(toIndex, 0, movedList);
              await this.saveData();
            }
          }
        }
      }
    };
    container.ondragover = (e) => {
      const dragging = container.querySelector(".list-sidebar-item.dragging");
      if (dragging) {
        const target = e.target;
        const itemsContainer = target.closest(".list-sidebar-items");
        if (!itemsContainer) {
          e.preventDefault();
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "none";
          }
        } else {
          const dragData = dragging.dataset;
          const dragListIndex = parseInt(dragData.listIndex || "-1");
          const listEl = itemsContainer.closest(".list-sidebar-list");
          const currentListIndex = listEl ? parseInt(listEl.dataset.listIndex || "-1") : -1;
          if (dragListIndex !== currentListIndex) {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = "none";
            }
          }
        }
      }
    };
    container.ondrop = (e) => {
      const dragging = container.querySelector(".list-sidebar-item.dragging");
      if (dragging) {
        const target = e.target;
        const itemsContainer = target.closest(".list-sidebar-items");
        if (!itemsContainer) {
          e.preventDefault();
          this.render();
        } else {
          const dragData = dragging.dataset;
          const dragListIndex = parseInt(dragData.listIndex || "-1");
          const listEl = itemsContainer.closest(".list-sidebar-list");
          const currentListIndex = listEl ? parseInt(listEl.dataset.listIndex || "-1") : -1;
          if (dragListIndex !== currentListIndex) {
            e.preventDefault();
            this.render();
          }
        }
      }
    };
    this.lists.forEach((list, listIndex) => {
      this.renderList(listsContainer, list, listIndex);
    });
    const addListBtn = container.createEl("button", {
      cls: "list-sidebar-add-list-btn",
      attr: { "aria-label": "Add List" }
    });
    addListBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    addListBtn.onclick = () => {
      this.showAddListInput(listsContainer);
    };
  }
  renderList(container, list, listIndex) {
    const listEl = container.createDiv("list-sidebar-list");
    listEl.draggable = true;
    listEl.dataset.listIndex = listIndex.toString();
    let dragStartIndex = listIndex;
    let isValidDrop = false;
    listEl.ondragstart = (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", listIndex.toString());
      }
      listEl.classList.add("dragging");
      listEl.dataset.dragProcessed = "false";
      dragStartIndex = listIndex;
      isValidDrop = false;
    };
    listEl.ondragend = async (e) => {
      const wasProcessed = listEl.dataset.dragProcessed === "true";
      listEl.classList.remove("dragging");
      delete listEl.dataset.dragProcessed;
      if (wasProcessed || isValidDrop) {
        this.render();
        return;
      }
      const finalIndex = Array.from(container.children).filter(
        (el) => el.classList.contains("list-sidebar-list")
      ).indexOf(listEl);
      if (finalIndex === dragStartIndex) {
        this.render();
      } else if (finalIndex !== dragStartIndex) {
        const validIndex = Math.min(Math.max(0, finalIndex), this.lists.length - 1);
        if (validIndex >= 0 && validIndex !== dragStartIndex && validIndex < this.lists.length) {
          const [movedList] = this.lists.splice(dragStartIndex, 1);
          this.lists.splice(validIndex, 0, movedList);
          await this.saveData();
          this.render();
        } else {
          this.render();
        }
      }
    };
    listEl.ondragover = (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
      const afterElement = this.getDragAfterElement(container, e.clientY, "list");
      const dragging = container.querySelector(".dragging");
      if (dragging) {
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      }
    };
    listEl.ondrop = async (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        const fromIndex = parseInt(e.dataTransfer.getData("text/plain"));
        const toIndex = Array.from(container.children).filter(
          (el) => el.classList.contains("list-sidebar-list")
        ).indexOf(listEl);
        if (fromIndex !== toIndex && !isNaN(fromIndex) && toIndex >= 0 && toIndex < this.lists.length) {
          isValidDrop = true;
          listEl.dataset.dragProcessed = "true";
          const [movedList] = this.lists.splice(fromIndex, 1);
          this.lists.splice(toIndex, 0, movedList);
          await this.saveData();
        }
      }
    };
    const headerEl = listEl.createDiv("list-sidebar-list-header");
    headerEl.style.cursor = "pointer";
    headerEl.onclick = async (e) => {
      if (e.target.closest(".list-sidebar-delete-btn")) {
        return;
      }
      if (e.detail === 2) {
        return;
      }
      list.expanded = !list.expanded;
      await this.saveData();
      this.render();
    };
    const toggleBtn = headerEl.createDiv("list-sidebar-toggle-btn");
    toggleBtn.innerHTML = list.expanded ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>' : '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>';
    const nameEl = headerEl.createEl("span", {
      text: list.name,
      cls: "list-sidebar-list-name"
    });
    nameEl.style.cursor = "pointer";
    nameEl.ondblclick = (e) => {
      e.stopPropagation();
      this.showEditListNameInput(nameEl, listIndex, list.name);
    };
    const deleteListBtn = headerEl.createEl("button", {
      cls: "list-sidebar-delete-btn",
      attr: { "aria-label": "Delete List" }
    });
    deleteListBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
    deleteListBtn.onclick = async () => {
      const confirmed = await this.showConfirmDialog(`Delete list "${list.name}"?`);
      if (confirmed) {
        this.lists.splice(listIndex, 1);
        await this.saveData();
        this.render();
      }
    };
    if (list.expanded) {
      const itemsContainer = listEl.createDiv("list-sidebar-items");
      if (this.plugin.settings.showDividers) {
        itemsContainer.classList.add("show-dividers");
      }
      list.items.forEach((item, itemIndex) => {
        this.renderItem(itemsContainer, item, listIndex, itemIndex, list.items.length);
      });
      const addItemBtn = itemsContainer.createEl("button", {
        cls: "list-sidebar-add-item-btn",
        attr: { "aria-label": "Add Item" }
      });
      addItemBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
      addItemBtn.onclick = () => {
        this.showAddItemInput(itemsContainer, listIndex);
      };
    }
  }
  renderItem(container, item, listIndex, itemIndex, totalItems) {
    const itemEl = container.createDiv("list-sidebar-item");
    itemEl.style.cursor = "pointer";
    itemEl.draggable = true;
    itemEl.dataset.itemIndex = itemIndex.toString();
    itemEl.dataset.listIndex = listIndex.toString();
    if (this.plugin.settings.alternateBackground && itemIndex % 2 === 1) {
      itemEl.classList.add("list-sidebar-item-alternate");
    }
    let dragStartItemIndex = itemIndex;
    let isValidItemDrop = false;
    itemEl.ondragstart = (e) => {
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", JSON.stringify({ listIndex, itemIndex }));
      }
      itemEl.classList.add("dragging");
      dragStartItemIndex = itemIndex;
      isValidItemDrop = false;
    };
    itemEl.ondragend = async (e) => {
      itemEl.classList.remove("dragging");
      const itemsContainer = itemEl.closest(".list-sidebar-items");
      if (!itemsContainer || itemsContainer !== container) {
        this.render();
        return;
      }
      if (e.dataTransfer && e.dataTransfer.dropEffect === "none") {
        this.render();
        return;
      }
      const finalIndex = Array.from(container.children).filter(
        (el) => el.classList.contains("list-sidebar-item")
      ).indexOf(itemEl);
      if (finalIndex === dragStartItemIndex && !isValidItemDrop) {
        this.render();
      }
    };
    itemEl.ondragover = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const dragging = container.querySelector(".dragging");
      if (!dragging)
        return;
      const draggingContainer = dragging.closest(".list-sidebar-items");
      if (!draggingContainer || draggingContainer !== container) {
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
        return;
      }
      const dragData = dragging.dataset;
      const dragListIndex = parseInt(dragData.listIndex || "-1");
      if (dragListIndex === listIndex) {
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
        const afterElement = this.getDragAfterElement(container, e.clientY, "item");
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      } else {
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
      }
    };
    itemEl.ondrop = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        try {
          const data = JSON.parse(e.dataTransfer.getData("text/plain"));
          const fromListIndex = data.listIndex;
          const fromItemIndex = data.itemIndex;
          const toItemIndex = Array.from(container.children).filter(
            (el) => el.classList.contains("list-sidebar-item")
          ).indexOf(itemEl);
          if (fromListIndex === listIndex && fromItemIndex !== toItemIndex && !isNaN(fromItemIndex) && !isNaN(toItemIndex) && toItemIndex >= 0 && toItemIndex < this.lists[listIndex].items.length) {
            isValidItemDrop = true;
            const [movedItem] = this.lists[listIndex].items.splice(fromItemIndex, 1);
            this.lists[listIndex].items.splice(toItemIndex, 0, movedItem);
            await this.saveData();
            this.render();
          }
        } catch (error) {
          this.render();
        }
      }
    };
    const contentEl = itemEl.createDiv("list-sidebar-item-content");
    contentEl.createEl("span", {
      text: item.content
    });
    itemEl.ondblclick = (e) => {
      e.stopPropagation();
      this.showEditItemInput(itemEl, contentEl, listIndex, itemIndex, item.content);
    };
    const btnContainer = itemEl.createDiv("list-sidebar-item-buttons");
    const deleteItemBtn = btnContainer.createEl("button", {
      cls: "list-sidebar-delete-item-btn",
      attr: { "aria-label": "Delete Item" }
    });
    deleteItemBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
    deleteItemBtn.onclick = async () => {
      this.lists[listIndex].items.splice(itemIndex, 1);
      await this.saveData();
      this.render();
    };
  }
  async refresh() {
    await this.loadData();
    this.render();
  }
  getDragAfterElement(container, y, type) {
    const draggableElements = Array.from(container.children).filter((el) => {
      return el.classList.contains(type === "list" ? "list-sidebar-list" : "list-sidebar-item") && !el.classList.contains("dragging");
    });
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
  }
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const modal = new ConfirmModal(this.app, message, (confirmed) => {
        resolve(confirmed);
      });
      modal.open();
    });
  }
  showAddListInput(container) {
    const textareaEl = container.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.placeholder = "List name";
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value) {
        const newList = {
          name: value,
          expanded: true,
          items: []
        };
        this.lists.push(newList);
        await this.saveData();
        this.render();
      } else {
        textareaEl.remove();
      }
    };
    textareaEl.focus();
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        textareaEl.remove();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showAddItemInput(container, listIndex) {
    const textareaEl = container.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.placeholder = "Item content";
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value) {
        const newItem = {
          content: value
        };
        this.lists[listIndex].items.push(newItem);
        await this.saveData();
        this.render();
      } else {
        textareaEl.remove();
      }
    };
    textareaEl.focus();
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        textareaEl.remove();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showEditListNameInput(nameEl, listIndex, currentValue) {
    const originalText = nameEl.textContent;
    nameEl.empty();
    const textareaEl = nameEl.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.value = currentValue;
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    adjustHeight();
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value && value !== currentValue) {
        this.lists[listIndex].name = value;
        await this.saveData();
        this.render();
      } else if (!value) {
        this.render();
      } else {
        this.render();
      }
    };
    textareaEl.focus();
    textareaEl.select();
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.render();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showEditItemInput(itemEl, contentEl, listIndex, itemIndex, currentValue) {
    contentEl.empty();
    const textareaEl = contentEl.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.value = currentValue;
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    adjustHeight();
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value && value !== currentValue) {
        this.lists[listIndex].items[itemIndex].content = value;
        await this.saveData();
        this.render();
      } else if (!value) {
        this.lists[listIndex].items.splice(itemIndex, 1);
        await this.saveData();
        this.render();
      } else {
        this.render();
      }
    };
    textareaEl.focus();
    textareaEl.select();
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.render();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, message, onSubmit) {
    super(app);
    this.message = message;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const confirmBtn = buttonContainer.createEl("button", {
      text: "OK",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    confirmBtn.onclick = () => {
      this.onSubmit(true);
      this.close();
    };
    cancelBtn.onclick = () => {
      this.onSubmit(false);
      this.close();
    };
    confirmBtn.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  filePath: "list-sidebar-data.md",
  showDividers: true,
  alternateBackground: true
};
var ListSidebarPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_LIST_SIDEBAR,
      (leaf) => {
        const view = new ListView(leaf, this);
        this.listView = view;
        return view;
      }
    );
    this.addRibbonIcon("layers", "List Sidebar", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-list-sidebar",
      name: "Open List Sidebar",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new ListSidebarSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_LIST_SIDEBAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_LIST_SIDEBAR)[0];
    if (!leaf) {
      const newLeaf = workspace.getLeftLeaf(false);
      if (newLeaf) {
        await newLeaf.setViewState({ type: VIEW_TYPE_LIST_SIDEBAR, active: true });
        leaf = newLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadLists() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.settings.filePath);
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        return [];
      }
      const content = await this.app.vault.read(file);
      return this.parseMarkdownFile(content);
    } catch (error) {
      console.error("\u52A0\u8F7D\u5217\u8868\u6570\u636E\u5931\u8D25:", error);
      return [];
    }
  }
  async saveLists(lists) {
    try {
      const content = this.generateMarkdownFile(lists);
      const file = this.app.vault.getAbstractFileByPath(this.settings.filePath);
      if (file && file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, content);
      } else {
        await this.app.vault.create(this.settings.filePath, content);
      }
    } catch (error) {
      console.error("\u4FDD\u5B58\u5217\u8868\u6570\u636E\u5931\u8D25:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian2.Notice("\u4FDD\u5B58\u5217\u8868\u6570\u636E\u5931\u8D25: " + errorMessage);
    }
  }
  parseMarkdownFile(content) {
    const lists = [];
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/);
    let metadata = {};
    if (frontmatterMatch) {
      try {
        const yamlContent = frontmatterMatch[1];
        const lines = yamlContent.split("\n");
        let currentList = null;
        lines.forEach((line) => {
          const listMatch = line.match(/^(\w+):$/);
          if (listMatch) {
            if (currentList) {
              lists.push(currentList);
            }
            currentList = {
              name: listMatch[1],
              expanded: true,
              items: []
            };
          } else if (currentList && line.trim().startsWith("- ")) {
            const itemContent = line.trim().substring(2);
            currentList.items.push({ content: itemContent });
          } else if (line.trim().startsWith("expanded:")) {
            currentList.expanded = line.trim().substring(9).trim() === "true";
          }
        });
        if (currentList) {
          lists.push(currentList);
        }
      } catch (e) {
        console.error("\u89E3\u6790YAML\u5931\u8D25:", e);
      }
    }
    if (lists.length === 0) {
      const bodyContent = frontmatterMatch ? content.substring(frontmatterMatch[0].length) : content;
      const lines = bodyContent.split("\n");
      let currentList = null;
      lines.forEach((line) => {
        const listHeaderMatch = line.match(/^## (.+?)(\s*<!--.*?-->)?$/);
        if (listHeaderMatch) {
          if (currentList) {
            lists.push(currentList);
          }
          const listName = listHeaderMatch[1].trim();
          const expandedComment = listHeaderMatch[2] || "";
          const isExpanded = expandedComment.includes("expanded:true");
          currentList = {
            name: listName,
            expanded: isExpanded,
            items: []
          };
        } else if (currentList && line.trim().startsWith("- ")) {
          const itemContent = line.trim().substring(2);
          currentList.items.push({ content: itemContent });
        }
      });
      if (currentList) {
        lists.push(currentList);
      }
    }
    return lists.length > 0 ? lists : [];
  }
  generateMarkdownFile(lists) {
    let content = "";
    lists.forEach((list, index) => {
      if (index > 0) {
        content += "\n";
      }
      const expandedMarker = list.expanded ? "<!-- expanded:true -->" : "<!-- expanded:false -->";
      content += `## ${list.name} ${expandedMarker}

`;
      list.items.forEach((item) => {
        content += `- ${item.content}
`;
      });
    });
    return content;
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById(this.manifest.id);
  }
};
var ListSidebarSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "List Sidebar Settings" });
    new import_obsidian2.Setting(containerEl).setName("Data File Path").setDesc("Markdown file path to save list data (relative to vault root)").addText((text) => text.setPlaceholder("e.g., list-sidebar-data.md").setValue(this.plugin.settings.filePath).onChange(async (value) => {
      this.plugin.settings.filePath = value;
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Dividers").setDesc("Show thin horizontal lines between items").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDividers).onChange(async (value) => {
      this.plugin.settings.showDividers = value;
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Alternate Background").setDesc("Use subtle alternating background colors for items").addToggle((toggle) => toggle.setValue(this.plugin.settings.alternateBackground).onChange(async (value) => {
      this.plugin.settings.alternateBackground = value;
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
  }
};
